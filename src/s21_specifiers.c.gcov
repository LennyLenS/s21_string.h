        -:    0:Source:specificators/s21_specifiers.c
        -:    1:#include "s21_specifiers.h"
        -:    2:
        -:    3:#include <math.h>
        -:    4:#include <stdarg.h>
        -:    5:
      141:    6:int specifier_f(char *buff, va_list args, Prototype prot) {
      141:    7:  if (prot.prec_number == -1) {
       44:    8:    prot.prec_number = 6;
        -:    9:  }
      141:   10:  if (prot.length == 'L') {
       66:   11:    long double a = va_arg(args, long double);
       66:   12:    s21_long_double_to_str(a, buff, prot.prec_number, prot.sharp_flag);
        -:   13:  } else {
       75:   14:    double a = va_arg(args, double);
       75:   15:    s21_long_double_to_str(a, buff, prot.prec_number, prot.sharp_flag);
        -:   16:  }
      141:   17:  return s21_strlen(buff);
        -:   18:}
        -:   19:
       86:   20:int specifier_o(char *buff, va_list args, Prototype prot) {
       86:   21:  if (prot.length == 'l') {
        6:   22:    unsigned long int num = va_arg(args, unsigned long int);
        6:   23:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        1:   24:      buff[0] = '\0';
       5*:   25:    } else if (!(num == 0 && prot.prec_number == 0)) {
        5:   26:      UDecInNumSys(buff, num, 8, 0);
        -:   27:    } else {
    #####:   28:      buff[0] = ' ';
        -:   29:    }
        -:   30:  } else {
       80:   31:    unsigned int num = va_arg(args, unsigned int);
       80:   32:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        3:   33:      buff[0] = '\0';
       77:   34:    } else if (!(num == 0 && prot.prec_number == 0)) {
       76:   35:      UDecInNumSys(buff, num, 8, 0);
        -:   36:    } else {
        1:   37:      buff[0] = ' ';
        -:   38:    }
        -:   39:  }
        -:   40:
       86:   41:  return s21_strlen(buff);
        -:   42:}
        -:   43:
       80:   44:int specifier_u(char *buff, va_list args, Prototype prot) {
       80:   45:  if (prot.length == 'l') {
        4:   46:    unsigned long int num = va_arg(args, unsigned long int);
        4:   47:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        1:   48:      buff[0] = '\0';
       3*:   49:    } else if (!(num == 0 && prot.prec_number == 0)) {
        3:   50:      UDecInNumSys(buff, num, 10, 0);
        -:   51:    } else {
    #####:   52:      buff[0] = ' ';
        -:   53:    }
        -:   54:  } else {
       76:   55:    unsigned int num = va_arg(args, unsigned int);
       76:   56:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        5:   57:      buff[0] = '\0';
       71:   58:    } else if (!(num == 0 && prot.prec_number == 0)) {
       69:   59:      UDecInNumSys(buff, num, 10, 0);
        -:   60:    } else {
        2:   61:      buff[0] = ' ';
        -:   62:    }
        -:   63:  }
       80:   64:  return s21_strlen(buff);
        -:   65:}
        -:   66:
       75:   67:int specifier_X(char *buff, va_list args, Prototype prot) {
       75:   68:  if (prot.length == 'l') {
        3:   69:    unsigned long int num = va_arg(args, unsigned long int);
        3:   70:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        1:   71:      buff[0] = '\0';
       2*:   72:    } else if (!(num == 0 && prot.prec_number == 0)) {
        2:   73:      UDecInNumSys(buff, num, 16, 1);
        -:   74:    } else {
    #####:   75:      buff[0] = ' ';
        -:   76:    }
        -:   77:  } else {
       72:   78:    unsigned int num = va_arg(args, unsigned int);
       72:   79:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        3:   80:      buff[0] = '\0';
       69:   81:    } else if (!(num == 0 && prot.prec_number == 0)) {
       68:   82:      UDecInNumSys(buff, num, 16, 1);
        -:   83:    } else {
        1:   84:      buff[0] = ' ';
        -:   85:    }
        -:   86:  }
        -:   87:
       75:   88:  return s21_strlen(buff);
        -:   89:}
        -:   90:
       71:   91:int specifier_x(char *buff, va_list args, Prototype prot) {
       71:   92:  if (prot.length == 'l') {
        4:   93:    unsigned long int num = va_arg(args, unsigned long int);
        4:   94:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        1:   95:      buff[0] = '\0';
       3*:   96:    } else if (!(num == 0 && prot.prec_number == 0)) {
        3:   97:      UDecInNumSys(buff, num, 16, 0);
        -:   98:    } else {
    #####:   99:      buff[0] = ' ';
        -:  100:    }
        -:  101:  } else {
       67:  102:    unsigned int num = va_arg(args, unsigned int);
       67:  103:    if (num == 0 && prot.prec_number == 0 && prot.width_number == 0) {
        3:  104:      buff[0] = '\0';
       64:  105:    } else if (!(num == 0 && prot.prec_number == 0)) {
       63:  106:      UDecInNumSys(buff, num, 16, 0);
        -:  107:    } else {
        1:  108:      buff[0] = ' ';
        -:  109:    }
        -:  110:  }
        -:  111:
       71:  112:  return s21_strlen(buff);
        -:  113:}
        -:  114:
       62:  115:int s21_spec_p(va_list args, char *charbuf, Prototype *prot) {
       62:  116:  void *num = va_arg(args, void *);
       62:  117:  char buff[512] = {'\0'};
       62:  118:  long long int num2 = (long long int)num;
       62:  119:  if (num == S21_NULL) num2 = 0;
       62:  120:  int i = 0;
       62:  121:  UDecInNumSys(buff, num2, 16, 0);
        -:  122:
       62:  123:  int p_len = s21_strlen(buff);
       62:  124:  int space_len = 0;
       62:  125:  int zero_len = 0;
       62:  126:  if (prot->prec_number > p_len) zero_len = prot->prec_number - p_len;
       62:  127:  if (prot->width_number > p_len + zero_len + 2)
        3:  128:    space_len = prot->width_number - (p_len + zero_len + 2);
        -:  129:
       62:  130:  if (prot->minus_flag != 1) {
       64:  131:    for (int k = 0; k < space_len; k++) {
        8:  132:      *(charbuf + i) = ' ';
        8:  133:      i++;
        -:  134:    };
        -:  135:  }
        -:  136:
       62:  137:  s21_strcat(charbuf, "0x");
       62:  138:  i += 2;
        -:  139:
       92:  140:  for (int k = 0; k < zero_len; k++) {
       30:  141:    *(charbuf + i) = '0';
       30:  142:    i++;
        -:  143:  };
        -:  144:
       62:  145:  s21_strcat(charbuf, buff);
       62:  146:  i += p_len;
       62:  147:  if (prot->minus_flag == 1) {
       11:  148:    for (int k = 0; k < space_len; k++) {
        5:  149:      *(charbuf + i) = ' ';
        5:  150:      i++;
        -:  151:    };
        -:  152:  }
       62:  153:  return s21_strlen(charbuf);
        -:  154:}
        -:  155:
        5:  156:void s21_spec_n(va_list args, int j) {
        5:  157:  int *var = va_arg(args, int *);
        5:  158:  *var = j;
        5:  159:}
        -:  160:
      192:  161:int s21_spec_id(va_list args, Prototype *prot, char *charbuf) {
      192:  162:  __int128_t num = 0;
      192:  163:  int neg_flag = 0;
      192:  164:  if (prot->length == 'h') {
        6:  165:    num = (short)va_arg(args, int);
      186:  166:  } else if (prot->length == 'l') {
        6:  167:    num = va_arg(args, long int);
        -:  168:  } else {
      180:  169:    num = va_arg(args, int);
        -:  170:  };
        -:  171:
      192:  172:  int num_i = 0;
        -:  173:
      192:  174:  if (num < 0) {
       90:  175:    neg_flag = 1;
       90:  176:    num *= -1;
       90:  177:    charbuf[num_i] = '-';
       90:  178:    num_i = 1;
        -:  179:  }
        -:  180:
      192:  181:  if (num == 0) {
       18:  182:    if (prot->prec_number == 0) {
        6:  183:      charbuf[num_i] = '\0';
        6:  184:      num_i++;
        -:  185:    } else {
       12:  186:      charbuf[num_i] = '0';
       12:  187:      num_i++;
        -:  188:    }
        -:  189:
        -:  190:  } else {
      827:  191:    while (num > 0) {
      653:  192:      int tmp_dig = 0;
      653:  193:      tmp_dig = num % 10;
      653:  194:      num = num / 10;
      653:  195:      charbuf[num_i] = tmp_dig + '0';
      653:  196:      num_i++;
        -:  197:    }
        -:  198:  }
        -:  199:
      192:  200:  s21_reverse(charbuf, neg_flag);
      192:  201:  return num_i;
        -:  202:}
        -:  203:
      119:  204:int s21_spec_s(char *str, va_list args, Prototype *prot) {
      119:  205:  int i = 0;
      119:  206:  int len = 0;
      119:  207:  char *strng_arg = va_arg(args, char *);
        -:  208:
      119:  209:  if (strng_arg == S21_NULL) {
       21:  210:    if (prot->prec_number == 0) {
       10:  211:      i += prep_string(str, strng_arg, prot->prec_number, i);
        -:  212:    } else {
       11:  213:      s21_strncpy(str, "(null)", fmin(6, prot->prec_number));
        -:  214:    }
       21:  215:    return 2;
        -:  216:  }
        -:  217:
       98:  218:  len = (int)s21_strlen(strng_arg);
        -:  219:
       98:  220:  if (prot->prec_number < len && prot->prec_number != -1) {
       19:  221:    i += prep_string(str, strng_arg, prot->prec_number, i);
       79:  222:  } else if (prot->prec_number == 0) {
    #####:  223:    i += prep_string(str, strng_arg, prot->prec_number, i);
       79:  224:  } else if (len <= prot->prec_number || prot->prec_number == -1) {
       79:  225:    i += prep_string(str, strng_arg, len, i);
        -:  226:  }
        -:  227:
       98:  228:  return i;
        -:  229:}
        -:  230:
       65:  231:int s21_spec_c(char *str, va_list args, Prototype *prot) {
       65:  232:  char c = va_arg(args, int);
       65:  233:  int sp_qnt = 0;
       65:  234:  int i = 0;
       65:  235:  int ret = 0;
       65:  236:  if (prot->width_number > 0) {
       17:  237:    sp_qnt = prot->width_number - 1;
        -:  238:  };
       65:  239:  if (prot->minus_flag == 1) {
       13:  240:    str[i] = c;
       13:  241:    i++;
       13:  242:    i += print_spaces(str, sp_qnt, i);
        -:  243:  } else {
       52:  244:    i += print_spaces(str, sp_qnt, i);
       52:  245:    str[i] = c;
       52:  246:    i++;
        -:  247:  };
       65:  248:  if (c == 0) ret = -1;
       65:  249:  return ret;
        -:  250:}
        -:  251:
      209:  252:int s21_spec_e(int counter_symbols_str, char *intermediate_str, va_list args,
        -:  253:               Prototype *prot) {
      209:  254:  int e = 0;
      209:  255:  long long int num_int = 0;
      209:  256:  int symbol = 0;
      209:  257:  int num_i = 0;
      209:  258:  char str_int[512] = {'\0'};
      209:  259:  char str_double[270] = {'\0'};
      209:  260:  char str_double_g[270] = {'\0'};
      209:  261:  char symbol_e = '\0';
      209:  262:  char str_degree[560] = {'\0'};
      209:  263:  bool flag_zero = false;
      209:  264:  bool flag_zero_negative = false;
      209:  265:  bool flag_zero_plus = false;
      209:  266:  bool flag_minus_num = false;
      209:  267:  bool flag_minus_num_g = false;
      209:  268:  bool check_num_i_g = false;
      209:  269:  bool flag_g = false;
      209:  270:  bool this_is_used = false;
      209:  271:  bool flag_g_prec_1 = true;
      209:  272:  bool prec_0 = false;
      209:  273:  int save_precision_g_1 = 0;
      209:  274:  int have_precision_g = 0;
      209:  275:  unsigned long int multiply = 1;
      209:  276:  int dont_write_number_with_point = 0;
      209:  277:  int check_g = 0;
      209:  278:  int precision = 6;
      209:  279:  int save_precision_for_rounding_g = 0;
      209:  280:  int save_multiply = 0;
      209:  281:  int save_degree = 0;
      209:  282:  unsigned long int multiply_for_fractional_num = 1;
      209:  283:  long int multiply_num_i_g = 1;
      209:  284:  int num_i_g = 0;
      209:  285:  double num = 0.;
      209:  286:  if (prot->length == 'L')
       29:  287:    num = va_arg(args, long double);
        -:  288:  else
      180:  289:    num = va_arg(args, double);
      209:  290:  double save_number_for_g = num;
      209:  291:  if (s21_check_arg(prot, intermediate_str, counter_symbols_str, num) != 0) {
        2:  292:    return counter_symbols_str;
        -:  293:  }
      207:  294:  if (prot->spec == 'g' || prot->spec == 'G') flag_g = true;
      207:  295:  if ((prot->spec == 'e' || prot->spec == 'E') && (num < 1 && num > 0.0) &&
        7:  296:      flag_zero_plus == false)
        7:  297:    flag_zero_plus = true;
      207:  298:  if ((prot->spec == 'g' || prot->spec == 'G') && (num < 1 && num > 0.0) &&
       10:  299:      flag_zero_plus == false)
       10:  300:    flag_zero_plus = true;
      207:  301:  if ((prot->spec == 'g' || prot->spec == 'G') && (num < 0))
       55:  302:    flag_minus_num_g = true;
        -:  303:  flag_zero_negative =
      207:  304:      s21_mantisssa_and_degree(&num, flag_zero, &num_int, &e, prot);
      207:  305:  if ((num_int == 0 || num_int == 1) &&
       12:  306:      (prot->spec == 'g' || prot->spec == 'G')) {
        7:  307:    if (num_int == 0) {
        6:  308:      str_int[0] = '0';
        -:  309:    } else
        1:  310:      str_int[0] = '1';
        7:  311:    s21_strcat(intermediate_str, str_int);
        7:  312:    return counter_symbols_str;
        -:  313:  }
     200*:  314:  if (flag_g == true && 1 > e && e >= -4 &&
    #####:  315:      (prot->prec_number == 1 || prot->prec_star == 1))
    #####:  316:    flag_g_prec_1 = false;
      200:  317:  if (prot->prec_number == 0 || prot->prec_star == 0) {
       60:  318:    num = round(num * pow(10, 0)) / pow(10, 0);
       60:  319:    prec_0 = true;
      140:  320:  } else if ((prot->prec_number == 1 || prot->prec_star == 1) &&
       14:  321:             (flag_g_prec_1 = true) && (flag_g == true)) {
        4:  322:    num = round(num * pow(10, 0)) / pow(10, 0);
       4*:  323:    if (num == 10) num /= 10;
        -:  324:  }
      200:  325:  s21_fractional_and_integer_part_of_a_number(
        -:  326:      &num_int, &num, prot, flag_zero_negative, flag_minus_num_g);
      200:  327:  dont_write_number_with_point = s21_rounding_and_precision_number(
        -:  328:      &num, &multiply, prot, &save_number_for_g, &e, &check_g, &precision,
        -:  329:      flag_zero_plus, flag_zero_negative, flag_g,
        -:  330:      &save_precision_for_rounding_g, this_is_used, &have_precision_g,
        -:  331:      &save_precision_g_1, &save_degree, &num_int);
      200:  332:  if (check_g != 1) {
      157:  333:    s21_writing_int_number_with_point(
        -:  334:        &num_int, &symbol, str_int, flag_zero_negative, &counter_symbols_str,
        -:  335:        &dont_write_number_with_point, &save_number_for_g, prot, &num_i_g,
        -:  336:        flag_minus_num, &have_precision_g, &save_precision_g_1, &save_degree,
        -:  337:        &e);
      157:  338:    counter_symbols_str = s21_concat_fractional_number_with_degree(
        -:  339:        num_i, counter_symbols_str, str_double, num, prot, symbol_e, e,
        -:  340:        str_degree, &dont_write_number_with_point);
      157:  341:    s21_check_fractional_number_for_zeros(&multiply, str_double, flag_minus_num,
        -:  342:                                          flag_g, this_is_used);
      157:  343:    bool point_is_not_here = false;
      157:  344:    if ((str_double[0] == 'e' || str_double[0] == 'E') &&
       64:  345:        prot->sharp_flag == 0 && flag_g == true) {
       18:  346:      int n = 0;
       18:  347:      point_is_not_here = true;
       50:  348:      for (; str_int[n] != '\0'; n++) {
        -:  349:      }
       18:  350:      if (str_int[n - 1] == '.') {
        2:  351:        n--;
        2:  352:        str_int[n] = '\0';
        -:  353:      }
        -:  354:    }
      157:  355:    if (prot->sharp_flag == 1 &&
       19:  356:        (str_double[0] == 'e' || str_double[0] == 'E')) {
       13:  357:      int i = 0;
       36:  358:      for (; str_int[i] != '\0'; i++) {
        -:  359:      }
       13:  360:      if (str_int[i - 1] == '.') {
    #####:  361:        str_int[i] = '\0';
        -:  362:      } else {
       13:  363:        str_int[i] = '.';
       13:  364:        str_int[i + 1] = '\0';
        -:  365:      }
        -:  366:    }
      157:  367:    s21_strcat(str_int, str_double);  // соединяем 2 строки получаем число
      157:  368:    if (flag_g == true && prot->sharp_flag == 0 && point_is_not_here == false)
       26:  369:      s21_leading_zeros(str_int, &save_precision_g_1, &have_precision_g,
        -:  370:                        &check_g, prec_0);
      157:  371:    s21_strcat(intermediate_str,
        -:  372:               str_int);  // закидываем готовый результат в промежуточную строку
        -:  373:  } else {
       43:  374:    s21_writing_int_number_with_point(
        -:  375:        &num_int, &symbol, str_int, flag_zero_negative, &counter_symbols_str,
        -:  376:        &dont_write_number_with_point, &save_number_for_g, prot, &num_i_g,
        -:  377:        flag_minus_num, &have_precision_g, &save_precision_g_1, &save_degree,
        -:  378:        &e);
       43:  379:    save_multiply = multiply;
       43:  380:    precision++;
       43:  381:    s21_check_fractional_number_for_zeros(&multiply, str_double, flag_minus_num,
        -:  382:                                          flag_g, this_is_used);
       43:  383:    while (precision > 0 && multiply != 1) {
    #####:  384:      precision--;
    #####:  385:      save_multiply *= 10;
        -:  386:    }
        -:  387:
       43:  388:    save_number_for_g *= save_multiply;
       43:  389:    if (num_i_g == 0) {
    #####:  390:      while (precision > 0) {
    #####:  391:        precision--;
    #####:  392:        multiply_for_fractional_num *= 10;
        -:  393:      }
        -:  394:    } else
       43:  395:      num_i_g = precision - num_i_g;
       43:  396:    if (num_i_g != 0) {
      272:  397:      while (num_i_g > 0) {
      232:  398:        num_i_g--;
      232:  399:        multiply_num_i_g *= 10;
        -:  400:      }
       40:  401:      check_num_i_g = true;
        -:  402:    }
       43:  403:    s21_fractional_and_integer_part_of_a_number(&num_int, &save_number_for_g,
        -:  404:                                                prot, flag_zero_negative,
        -:  405:                                                flag_minus_num_g);
       43:  406:    if (save_multiply != 1) {
    #####:  407:      multiply_num_i_g /= save_multiply;
    #####:  408:      save_precision_for_rounding_g = 0;
        -:  409:    }
       43:  410:    if (num_i_g == 0 && check_num_i_g == false)
        3:  411:      save_number_for_g *= multiply_for_fractional_num;
        -:  412:    else {
       40:  413:      save_number_for_g *= multiply_num_i_g;
       40:  414:      save_number_for_g =
       40:  415:          round(save_number_for_g * pow(10, save_precision_for_rounding_g)) /
       40:  416:          pow(10, save_precision_for_rounding_g);
        -:  417:    }
       43:  418:    save_number_for_g = (long long int)save_number_for_g;
       43:  419:    s21_double_to_str(save_number_for_g, str_double_g, num_i);
       43:  420:    s21_reverse(str_double_g, 0);
       43:  421:    s21_strcat(str_double, str_double_g);
       43:  422:    s21_strcat(str_int, str_double);
       43:  423:    if (prot->sharp_flag == 0)
       42:  424:      s21_leading_zeros(str_int, &save_precision_g_1, &have_precision_g,
        -:  425:                        &check_g, prec_0);
       43:  426:    s21_strcat(intermediate_str, str_int);
        -:  427:  }
      200:  428:  return counter_symbols_str;
        -:  429:}
