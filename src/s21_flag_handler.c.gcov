        -:    0:Source:s21_flag_handler.c
        -:    1:#include "s21_sprintf.h"
        -:    2:#include "s21_string_files/s21_string.h"
        -:    3:
        -:    4:char *add_sign_or_space(char *buf_str, Prototype prot, int sign);
        -:    5:
        -:    6:char *main_func(char *str, Prototype *prot);
        -:    7:
        -:    8:char *add_char_left(char *str, int n, int str_size, char c, Prototype prot);
        -:    9:char *add_char_right(char *str, int n, int str_size, char c);
        -:   10:char *n_shift(char *str, int negativ_num, Prototype prot);
        -:   11:char *add_sharp_sign(char *str, Prototype prot);
        -:   12:
      973:   13:char *main_func(char *str, Prototype *prot) {
      973:   14:  prot->width_number =
      973:   15:      prot->width_number != 0 ? prot->width_number : prot->width_star;
        -:   16:  char *str1;
        -:   17:
        -:   18:  char *res;
        -:   19:  int negativ_num;
      973:   20:  if (*str == '-') {
      308:   21:    negativ_num = 1;
      308:   22:    str1 = (char *)malloc(s21_strlen(str));
     3414:   23:    for (int i = 1; i <= (int)s21_strlen(str); ++i) {
     3106:   24:      str1[i - 1] = str[i];
        -:   25:    }
        -:   26:  } else {
      665:   27:    str1 = (char *)malloc(s21_strlen(str) + 1);
     5191:   28:    for (int i = 0; i < (int)s21_strlen(str) + 1; ++i) {
     4526:   29:      str1[i] = str[i];
        -:   30:    }
      665:   31:    negativ_num = 0;
        -:   32:  }
      973:   33:  str = str1;
      973:   34:  if (prot->spec == 'f' || prot->spec == 'g' || prot->spec == 'G' ||
      730:   35:      prot->spec == 'e' || prot->spec == 'E') {
      350:   36:    prot->prec_number = -1;
        -:   37:  }
      973:   38:  if (prot->spec == 'o' || prot->spec == 'u' || prot->spec == 'x' ||
      736:   39:      prot->spec == 'X') {
      312:   40:    prot->plus_flag = 0;
      312:   41:    prot->space_flag = 0;
        -:   42:  }
      973:   43:  if (prot->spec != 's') {
      854:   44:    if (prot->prec_number != -1) {
      196:   45:      if (prot->spec == 'd' || prot->spec == 'i' || prot->spec == 'o' ||
     103*:   46:          prot->spec == 'u' || prot->spec == 'x' || prot->spec == 'X' ||
    #####:   47:          prot->spec == 'n') {  //  это только для целыx чисел
      196:   48:        if (prot->prec_number > (int)s21_strlen(str)) {
        -:   49:          char *buff_str =
       88:   50:              add_char_left(str, prot->prec_number - (int)s21_strlen(str) - 1,
       88:   51:                            (int)s21_strlen(str) + 1, '0', *prot);
       88:   52:          free(str);
       88:   53:          str = buff_str;
        -:   54:        }
        -:   55:      }
      196:   56:      if (prot->sharp_flag) {
       21:   57:        char *buff_str = add_sharp_sign(str, *prot);
       21:   58:        free(str);
       21:   59:        str = buff_str;
        -:   60:      }
      196:   61:      if (prot->width_number != 0 || prot->width_star != 0) {
       87:   62:        char *buff_str = n_shift(str, negativ_num, *prot);
       87:   63:        free(str);
       87:   64:        str = buff_str;
        -:   65:      } else {
      109:   66:        char *buff_str = add_sign_or_space(str, *prot, negativ_num);
      109:   67:        free(str);
      109:   68:        str = buff_str;
        -:   69:      }
        -:   70:    } else {
      658:   71:      if (prot->sharp_flag) {
       49:   72:        char *buff_str = add_sharp_sign(str, *prot);
       49:   73:        free(str);
       49:   74:        str = buff_str;
        -:   75:      }
      658:   76:      if (prot->width_number != 0 || prot->width_star != 0) {
      324:   77:        char *buff_str = n_shift(str, negativ_num, *prot);
      324:   78:        free(str);
      324:   79:        str = buff_str;
        -:   80:      } else {
      334:   81:        char *buff_str = add_sign_or_space(str, *prot, negativ_num);
      334:   82:        free(str);
      334:   83:        str = buff_str;
        -:   84:      }
        -:   85:    }
        -:   86:  } else {
      119:   87:    if (!prot->minus_flag) {
      113:   88:      if (prot->width_number > (int)s21_strlen(str)) {
        -:   89:        char *buff_str =
       22:   90:            add_char_left(str, prot->width_number - (int)s21_strlen(str) - 1,
       22:   91:                          (int)s21_strlen(str) + 1, ' ', *prot);
       22:   92:        free(str);
       22:   93:        str = buff_str;
        -:   94:      }
        -:   95:    } else {
        6:   96:      if (prot->width_number > (int)s21_strlen(str)) {
        -:   97:        char *buff_str =
        2:   98:            add_char_right(str, prot->width_number - (int)s21_strlen(str) - 1,
        2:   99:                           (int)s21_strlen(str) + 1, ' ');
        2:  100:        free(str);
        2:  101:        str = buff_str;
        -:  102:      }
        -:  103:    }
        -:  104:  }
      973:  105:  char *buff_str = add_char_right(str, 1, s21_strlen(str) + 1, '\0');
      973:  106:  free(str);
      973:  107:  str = buff_str;
        -:  108:
      973:  109:  res = str;
      973:  110:  return res;
        -:  111:}
        -:  112:
       70:  113:char *add_sharp_sign(char *str, Prototype prot) {
        -:  114:  char *res;
       70:  115:  if ((prot.spec == 'o' || prot.spec == 'x' || prot.spec == 'X') &&
       23:  116:      *str == '0' && s21_strlen(str) == 1) {
        3:  117:    res = (char *)malloc((s21_strlen(str) + 1) * sizeof(char));
        3:  118:    s21_memcpy(res, str, s21_strlen(str) + 1);
        -:  119:
       67:  120:  } else if ((prot.spec == 'o' &&
        5:  121:              (prot.prec_number == -1 || prot.prec_number == 0)) ||
       64:  122:             prot.spec == 'x' || prot.spec == 'X') {
       18:  123:    int n = prot.spec == 'o' ? 1 : 2;
        -:  124:
       18:  125:    res = (char *)malloc((s21_strlen(str) + 1 + n) * sizeof(char));
        -:  126:
      105:  127:    for (int i = n; i < (int)s21_strlen(str) + 2; i++) {
       87:  128:      res[i] = str[i - n];
        -:  129:    }
       18:  130:    if (prot.spec == 'o') {
        3:  131:      res[0] = '0';
       15:  132:    } else if (prot.spec == 'x' || prot.spec == 'X') {
       15:  133:      res[0] = '0';
       15:  134:      res[1] = prot.spec;
        -:  135:    }
       18:  136:    res[s21_strlen(str) + n] = '\0';
        -:  137:  } else {
       49:  138:    res = (char *)malloc((s21_strlen(str) + 1) * sizeof(char));
       49:  139:    s21_memcpy(res, str, s21_strlen(str) + 1);
        -:  140:  }
       70:  141:  return res;
        -:  142:}
        -:  143:
      411:  144:char *n_shift(char *str, int negativ_num, Prototype prot) {
      411:  145:  int sign_size = 0;
      411:  146:  if (negativ_num == 1 || prot.plus_flag == 1 || prot.space_flag) {
      241:  147:    sign_size = 1;
        -:  148:  }
      411:  149:  if (prot.minus_flag == 1) {
       95:  150:    if ((int)s21_strlen(str) >= (prot.width_number + prot.width_star)) {
        4:  151:      char *buff_str = add_sign_or_space(str, prot, negativ_num);
        4:  152:      str = buff_str;
        -:  153:    } else {
       91:  154:      int str_size = s21_strlen(str);
       91:  155:      char *buff_str = add_sign_or_space(str, prot, negativ_num);
       91:  156:      str = buff_str;
        -:  157:      buff_str =
       91:  158:          add_char_right(str, prot.width_number - str_size - 1 - sign_size,
       91:  159:                         str_size + 1 + sign_size, ' ');
        -:  160:
       91:  161:      free(str);
       91:  162:      str = buff_str;
        -:  163:    }
        -:  164:  } else {
      316:  165:    if ((int)s21_strlen(str) >= prot.width_number) {
      131:  166:      char *buff_str = add_sign_or_space(str, prot, negativ_num);
      131:  167:      str = buff_str;
        -:  168:    } else {
      185:  169:      if (prot.zero_flag || *str == '0') {
      106:  170:        char *buff_str = add_char_left(
       53:  171:            str, prot.width_number - s21_strlen(str) - 1 - sign_size,
       53:  172:            s21_strlen(str) + 1, ' ', prot);
       53:  173:        str = buff_str;
       53:  174:        buff_str = add_sign_or_space(str, prot, negativ_num);
       53:  175:        free(str);
       53:  176:        str = buff_str;
        -:  177:
        -:  178:      } else {
      132:  179:        int str_size = s21_strlen(str);
      132:  180:        char *buff_str = add_sign_or_space(str, prot, negativ_num);
      132:  181:        str = buff_str;
        -:  182:        buff_str =
      132:  183:            add_char_left(str, prot.width_number - str_size - 1 - sign_size,
      132:  184:                          str_size + 1 + sign_size, ' ', prot);
      132:  185:        free(str);
      132:  186:        str = buff_str;
        -:  187:      }
        -:  188:    }
        -:  189:  }
      411:  190:  return str;
        -:  191:}
        -:  192:
      854:  193:char *add_sign_or_space(char *buf_str, Prototype prot, int sign) {
        -:  194:  char *res;
     1235:  195:  if (prot.plus_flag == 1 || sign == 1 || prot.space_flag) {
      381:  196:    int str_size = s21_strlen(buf_str);
      381:  197:    res = (char *)malloc((str_size + 2) * sizeof(char));
        -:  198:
     4760:  199:    for (int i = 1; i < str_size + 2; i++) {
     4379:  200:      res[i] = buf_str[i - 1];
        -:  201:    }
        -:  202:
      381:  203:    if (sign == 1) {  // если отрицательное число то по дефолту ставим -
      308:  204:      res[0] = '-';
       73:  205:    } else if (sign == 0 && prot.plus_flag) {
       40:  206:      res[0] = '+';
       33:  207:    } else if (sign == 0 && !prot.plus_flag && prot.space_flag) {
       33:  208:      res[0] = ' ';
        -:  209:    }
        -:  210:  } else {
      473:  211:    int str_size = s21_strlen(buf_str);
      473:  212:    res = (char *)malloc((str_size + 1) * sizeof(char));
      473:  213:    s21_memcpy(res, buf_str, s21_strlen(buf_str) + 1);
        -:  214:  }
        -:  215:
      854:  216:  return res;
        -:  217:}
        -:  218:
      295:  219:char *add_char_left(char *str, int n, int str_size, char c, Prototype prot) {
      295:  220:  if (prot.zero_flag == 1) {
       54:  221:    c = '0';
        -:  222:  }
      295:  223:  int j = str_size - 1;
      295:  224:  char *res = (char *)malloc((str_size + n + 1) * sizeof(char));
        -:  225:
     5190:  226:  for (int i = str_size + n; i >= 0; i--) {
     4895:  227:    if (j >= 0) {
     2232:  228:      res[i] = str[j];
     2232:  229:      j--;
        -:  230:    } else {
     2663:  231:      res[i] = c;
        -:  232:    }
        -:  233:  }
      295:  234:  res[str_size + n] = '\0';
      295:  235:  return res;
        -:  236:}
        -:  237:
     1066:  238:char *add_char_right(char *str, int n, int str_size, char c) {
     1066:  239:  char *res = (char *)malloc((str_size + n + 1) * sizeof(char));
    15359:  240:  for (int i = 0; i < str_size + n; i++) {
    14293:  241:    if (i < str_size - 1) {
    11458:  242:      res[i] = str[i];
        -:  243:    } else {
     2835:  244:      res[i] = c;
        -:  245:    }
        -:  246:  }
     1066:  247:  res[str_size + n] = '\0';
     1066:  248:  return res;
        -:  249:}
