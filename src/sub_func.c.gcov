        -:    0:Source:specificators/sub_func.c
        -:    1:#include "sub_func.h"
        -:    2:
        -:    3:#include "../s21_string_files/s21_string.h"
     1576:    4:void shift_str(char *str, int size) {
     6430:    5:  for (int i = size - 1; i > 0; --i) {
     4854:    6:    str[i] = str[i - 1];
        -:    7:  }
     1576:    8:}
        -:    9:
      351:   10:void UDecInNumSys(char *buff, unsigned long long int n, int mes, int flag) {
      351:   11:  int size_ans = 0;
        -:   12:  char str[2];
      351:   13:  str[0] = 'a';
      351:   14:  str[1] = 'A';
      351:   15:  if (n == 0) {
       36:   16:    buff[size_ans++] = '0';
        -:   17:  } else {
     1887:   18:    while (n != 0) {
     1572:   19:      size_ans += 1;
     1572:   20:      shift_str(buff, size_ans);
     1572:   21:      if (n % mes > 9) {
      207:   22:        buff[0] = n % mes - 10 + str[flag];
        -:   23:      } else {
     1365:   24:        buff[0] = n % mes + '0';
        -:   25:      }
     1572:   26:      n /= mes;
        -:   27:    }
        -:   28:  }
      351:   29:  buff[size_ans] = '\0';
      351:   30:}
        -:   31:
       53:   32:int s21_rounding(char *str, int count_before_dot, int pres, int neg_flag,
        -:   33:                 int add_point, int index) {
       53:   34:  int trans = 1;
      524:   35:  for (int i = count_before_dot + pres - 1 + add_point + neg_flag; i > 0; --i) {
      471:   36:    if (str[i] != '.') {
      431:   37:      int a = str[i] - '0';
      431:   38:      str[i] = (a + trans) % 10 + '0';
      431:   39:      trans = (a + trans) / 10;
        -:   40:    }
        -:   41:  }
        -:   42:
       53:   43:  if (trans == 1 && str[0] == '9') {
    #####:   44:    shift_str(str, count_before_dot + pres - 1 + add_point + neg_flag);
    #####:   45:    str[1] = '0';
    #####:   46:    str[0] = '1';
       53:   47:  } else if (trans == 1 && str[0] == '-') {
        4:   48:    shift_str(str + 1, count_before_dot + pres + add_point + 1);
        4:   49:    str[1] = '1';
        4:   50:    index++;
       49:   51:  } else if (trans == 1) {
    #####:   52:    str[0] = str[0] + 1;
        -:   53:  }
        -:   54:
       53:   55:  return index;
        -:   56:}
      141:   57:void s21_long_double_to_str(long double num, char *str, int pres,
        -:   58:                            int sharp_flag) {
      141:   59:  int count_before_dot = 0, index = 0, neg_flag = 0;
      141:   60:  long double num1 = 0, num2 = num;
      141:   61:  if (num < 0) {
       80:   62:    str[index++] = '-';
       80:   63:    num *= -1;
       80:   64:    num2 *= -1;
       80:   65:    neg_flag = 1;
        -:   66:  }
     1182:   67:  while (num >= 1) {
     1041:   68:    num /= 10;
     1041:   69:    count_before_dot++;
        -:   70:  }
     1182:   71:  for (int i = 0; i < count_before_dot; ++i) {
     1041:   72:    num *= 10;
     1041:   73:    int y = (int)num;
     1041:   74:    num1 = num1 * 10 + y;
     1041:   75:    num -= y;
     1041:   76:    str[index++] = y + '0';
        -:   77:  }
        -:   78:
      141:   79:  if (count_before_dot == 0) {
       10:   80:    str[index++] = '0';
       10:   81:    count_before_dot = 1;
        -:   82:  }
      141:   83:  int add_point = 0;
      141:   84:  if (pres != 0 || sharp_flag == 1) {
      126:   85:    str[index++] = '.';
      126:   86:    add_point = 1;
        -:   87:  }
      141:   88:  num2 -= num1;
      141:   89:  int flag_bad = 0;
      141:   90:  if (num2 == 1.) {
        6:   91:    num2 = 0.;
        6:   92:    flag_bad = 1;
        -:   93:  }
      948:   94:  for (int i = 0; i < pres; ++i) {
      807:   95:    num2 *= 10;
      807:   96:    int y = (int)num2;
      807:   97:    num2 -= y;
      807:   98:    str[index++] = y + '0';
        -:   99:  }
      141:  100:  num2 *= 10;
      141:  101:  int y = (int)num2;
      141:  102:  if (y >= 5) {
        -:  103:    index =
       53:  104:        s21_rounding(str, count_before_dot, pres, neg_flag, add_point, index);
        -:  105:  }
      141:  106:  if (flag_bad == 1) {
        6:  107:    int trans = 1;
      114:  108:    for (int i = count_before_dot + neg_flag - 1; i > 0; --i) {
      108:  109:      if (str[i] != '.') {
      108:  110:        int a = str[i] - '0';
      108:  111:        str[i] = (a + trans) % 10 + '0';
      108:  112:        trans = (a + trans) / 10;
        -:  113:      }
        -:  114:    }
        -:  115:  }
      141:  116:  str[index] = '\0';
      141:  117:}
        -:  118:
      629:  119:void *s21_reverse(char *str, int neg_flag) {
     629*:  120:  if (str == NULL) return NULL;
      629:  121:  int bgn = 0;
      629:  122:  if (neg_flag == 1) bgn = 1;
      629:  123:  int end = s21_strlen(str) - 1;
        -:  124:  char temp;
     1433:  125:  while (bgn < end) {
      804:  126:    temp = str[bgn];
      804:  127:    *(str + bgn) = *(str + end);
      804:  128:    *(str + end) = temp;
      804:  129:    bgn++;
      804:  130:    end--;
        -:  131:  }
      629:  132:  return str;
        -:  133:}
        -:  134:
       65:  135:int print_spaces(char *str, int n, int j) {
      699:  136:  for (int i = 0; i < n; i++) str[j + i] = ' ';
       65:  137:  return n;
        -:  138:}
        -:  139:
      108:  140:int prep_string(char *str, char *strng_arg, int n, int j) {
     1200:  141:  for (int i = 0; i < n; i++) {
     1092:  142:    str[j + i] = strng_arg[i];
        -:  143:  };
      108:  144:  return n;
        -:  145:}
